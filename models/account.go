// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Account Account
// swagger:model Account

type Account struct {

	// { "description" : "If present, this will be the product rate plan to use when creating an aggregating subscription.  An account level aggregating subscription will be created when the first subscription is created against the account.", "verbs":[] }
	AggregatingProductRatePlanID string `json:"aggregatingProductRatePlanID,omitempty"`

	// { "description" : "The consistent ID of the account level aggregating subscription, if one exists.", "verbs":[] }
	AggregatingSubscriptionID string `json:"aggregatingSubscriptionID,omitempty"`

	// { "description" : "ID of the user who last updated the entity.", "verbs":[] }
	ChangedBy string `json:"changedBy,omitempty"`

	// { "description" : "The UTC DateTime when the object was created.", "verbs":[] }
	Created strfmt.DateTime `json:"created,omitempty"`

	// { "description" : "CRM ID of the account.", "verbs":["GET"] }
	CrmID string `json:"crmID,omitempty"`

	// {  "default" : "false",  "description" : "Indicates if an account has been retired. If an account has been retired it can still be retrieved using the appropriate flag on API requests.", "verbs":["GET"] }
	Deleted *bool `json:"deleted,omitempty"`

	// { "description" : "ID of the account.", "verbs":["GET"] }
	// Required: true
	ID *string `json:"id"`

	// { "description" : "Add metadata.", "verbs":["POST"] }
	Metadata DynamicMetadata `json:"metadata,omitempty"`

	// { "description" : "Organization associated with the account.", "verbs":[] }
	// Required: true
	OrganizationID *string `json:"organizationID"`

	// { "description" : "The payment-methods associated with the account.", "verbs":["GET"] }
	PaymentMethods []*PaymentMethod `json:"paymentMethods"`

	// profile
	Profile *Profile `json:"profile,omitempty"`

	// { "description" : "Number of distinct, paid subscriptions associated with this account. Initially the value will be 0 when no successful subscriptions have been taken. A subscription cancelled whilst in trial is counted as successful.", "verbs":["GET"] }
	SuccessfulSubscriptions int32 `json:"successfulSubscriptions,omitempty"`

	// { "description" : "The UTC DateTime when the object was last updated.", "verbs":[] }
	Updated strfmt.DateTime `json:"updated,omitempty"`

	// { "description" : "User associated with the account. If this is null, no user is currently assocaited with the account. A user is only set when an account is associated with a user account.", "verbs":[] }
	UserID string `json:"userID,omitempty"`
}

/* polymorph Account aggregatingProductRatePlanID false */

/* polymorph Account aggregatingSubscriptionID false */

/* polymorph Account changedBy false */

/* polymorph Account created false */

/* polymorph Account crmID false */

/* polymorph Account deleted false */

/* polymorph Account id false */

/* polymorph Account metadata false */

/* polymorph Account organizationID false */

/* polymorph Account paymentMethods false */

/* polymorph Account profile false */

/* polymorph Account successfulSubscriptions false */

/* polymorph Account updated false */

/* polymorph Account userID false */

// Validate validates this account
func (m *Account) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateOrganizationID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePaymentMethods(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProfile(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Account) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateOrganizationID(formats strfmt.Registry) error {

	if err := validate.Required("organizationID", "body", m.OrganizationID); err != nil {
		return err
	}

	return nil
}

func (m *Account) validatePaymentMethods(formats strfmt.Registry) error {

	if swag.IsZero(m.PaymentMethods) { // not required
		return nil
	}

	for i := 0; i < len(m.PaymentMethods); i++ {

		if swag.IsZero(m.PaymentMethods[i]) { // not required
			continue
		}

		if m.PaymentMethods[i] != nil {

			if err := m.PaymentMethods[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("paymentMethods" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Account) validateProfile(formats strfmt.Registry) error {

	if swag.IsZero(m.Profile) { // not required
		return nil
	}

	if m.Profile != nil {

		if err := m.Profile.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("profile")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Account) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Account) UnmarshalBinary(b []byte) error {
	var res Account
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
